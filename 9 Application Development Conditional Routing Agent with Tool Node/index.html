<!doctype html><html lang=en class=no-js> <head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="HADK 框架开发文档 - 跨端轻量级智能体开发框架"><meta name=author content=xufeng8@lenovo.com><link href=../8%20Application%20Development%20Three%20Node%20Agent/ rel=prev><link href=../10%20Application%20Development%20Inja%20Template%20Formatting/ rel=next><link rel=icon href=../assets/images/favicon.png><meta name=generator content="mkdocs-1.6.1, mkdocs-material-9.7.0"><title>Agent with Specified Tools - HADK</title><link rel=stylesheet href=../assets/stylesheets/main.618322db.min.css><link rel=stylesheet href=../assets/stylesheets/palette.ab4e12ef.min.css><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback"><style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style><script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script></head> <body dir=ltr data-md-color-scheme=default data-md-color-primary=pink data-md-color-accent=pink> <input class=md-toggle data-md-toggle=drawer type=checkbox id=__drawer autocomplete=off> <input class=md-toggle data-md-toggle=search type=checkbox id=__search autocomplete=off> <label class=md-overlay for=__drawer></label> <div data-md-component=skip> <a href=#conditional-routing-agent-with-tool-node-development-example class=md-skip> Skip to content </a> </div> <div data-md-component=announce> </div> <header class=md-header data-md-component=header> <nav class="md-header__inner md-grid" aria-label=Header> <a href=.. title=HADK class="md-header__button md-logo" aria-label=HADK data-md-component=logo> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg> </a> <label class="md-header__button md-icon" for=__drawer> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg> </label> <div class=md-header__title data-md-component=header-title> <div class=md-header__ellipsis> <div class=md-header__topic> <span class=md-ellipsis> HADK </span> </div> <div class=md-header__topic data-md-component=header-topic> <span class=md-ellipsis> Agent with Specified Tools </span> </div> </div> </div> <form class=md-header__option data-md-component=palette> <input class=md-option data-md-color-media data-md-color-scheme=default data-md-color-primary=pink data-md-color-accent=pink aria-label="Dark Mode" type=radio name=__palette id=__palette_0> <label class="md-header__button md-icon" title="Dark Mode" for=__palette_1 hidden> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M12 8a4 4 0 0 0-4 4 4 4 0 0 0 4 4 4 4 0 0 0 4-4 4 4 0 0 0-4-4m0 10a6 6 0 0 1-6-6 6 6 0 0 1 6-6 6 6 0 0 1 6 6 6 6 0 0 1-6 6m8-9.31V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12z"/></svg> </label> <input class=md-option data-md-color-media data-md-color-scheme=slate data-md-color-primary=pink data-md-color-accent=pink aria-label="Light Mode" type=radio name=__palette id=__palette_1> <label class="md-header__button md-icon" title="Light Mode" for=__palette_0 hidden> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M12 18c-.89 0-1.74-.2-2.5-.55C11.56 16.5 13 14.42 13 12s-1.44-4.5-3.5-5.45C10.26 6.2 11.11 6 12 6a6 6 0 0 1 6 6 6 6 0 0 1-6 6m8-9.31V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12z"/></svg> </label> </form> <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script> <label class="md-header__button md-icon" for=__search> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg> </label> <div class=md-search data-md-component=search role=dialog> <label class=md-search__overlay for=__search></label> <div class=md-search__inner role=search> <form class=md-search__form name=search> <input type=text class=md-search__input name=query aria-label=Search placeholder=Search autocapitalize=off autocorrect=off autocomplete=off spellcheck=false data-md-component=search-query required> <label class="md-search__icon md-icon" for=__search> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg> </label> <nav class=md-search__options aria-label=Search> <button type=reset class="md-search__icon md-icon" title=Clear aria-label=Clear tabindex=-1> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg> </button> </nav> <div class=md-search__suggest data-md-component=search-suggest></div> </form> <div class=md-search__output> <div class=md-search__scrollwrap tabindex=0 data-md-scrollfix> <div class=md-search-result data-md-component=search-result> <div class=md-search-result__meta> Initializing search </div> <ol class=md-search-result__list role=presentation></ol> </div> </div> </div> </div> </div> </nav> </header> <div class=md-container data-md-component=container> <nav class=md-tabs aria-label=Tabs data-md-component=tabs> <div class=md-grid> <ul class=md-tabs__list> <li class=md-tabs__item> <a href=.. class=md-tabs__link> Home </a> </li> <li class=md-tabs__item> <a href=../1%20Basic%20Concepts%20Chat%20Node/ class=md-tabs__link> Basic Concepts </a> </li> <li class="md-tabs__item md-tabs__item--active"> <a href=../6%20Application%20Development%20Single%20Node%20Agent/ class=md-tabs__link> Application Development </a> </li> </ul> </div> </nav> <main class=md-main data-md-component=main> <div class="md-main__inner md-grid"> <div class="md-sidebar md-sidebar--primary" data-md-component=sidebar data-md-type=navigation> <div class=md-sidebar__scrollwrap> <div class=md-sidebar__inner> <nav class="md-nav md-nav--primary md-nav--lifted" aria-label=Navigation data-md-level=0> <label class=md-nav__title for=__drawer> <a href=.. title=HADK class="md-nav__button md-logo" aria-label=HADK data-md-component=logo> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg> </a> HADK </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=.. class=md-nav__link> <span class=md-ellipsis> Home </span> </a> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle md-toggle--indeterminate" type=checkbox id=__nav_2> <label class=md-nav__link for=__nav_2 id=__nav_2_label tabindex=0> <span class=md-ellipsis> Basic Concepts </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=1 aria-labelledby=__nav_2_label aria-expanded=false> <label class=md-nav__title for=__nav_2> <span class="md-nav__icon md-icon"></span> Basic Concepts </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../1%20Basic%20Concepts%20Chat%20Node/ class=md-nav__link> <span class=md-ellipsis> Chat Node </span> </a> </li> <li class=md-nav__item> <a href=../2%20Basic%20Concepts%20Tool%20Node/ class=md-nav__link> <span class=md-ellipsis> Tool Node </span> </a> </li> <li class=md-nav__item> <a href=../3%20Basic%20Concepts%20DIY%20Node/ class=md-nav__link> <span class=md-ellipsis> DIY Node </span> </a> </li> <li class=md-nav__item> <a href=../4%20Basic%20Concepts%20Route/ class=md-nav__link> <span class=md-ellipsis> Route </span> </a> </li> <li class=md-nav__item> <a href=../5%20Basic%20Concepts%20Chain%20Flow/ class=md-nav__link> <span class=md-ellipsis> Chain and Flow </span> </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--active md-nav__item--section md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_3 checked> <label class=md-nav__link for=__nav_3 id=__nav_3_label tabindex> <span class=md-ellipsis> Application Development </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=1 aria-labelledby=__nav_3_label aria-expanded=true> <label class=md-nav__title for=__nav_3> <span class="md-nav__icon md-icon"></span> Application Development </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../6%20Application%20Development%20Single%20Node%20Agent/ class=md-nav__link> <span class=md-ellipsis> Single Node Agent </span> </a> </li> <li class=md-nav__item> <a href=../7%20Application%20Development%20Two%20Node%20Agent/ class=md-nav__link> <span class=md-ellipsis> Two Node Agent </span> </a> </li> <li class=md-nav__item> <a href=../8%20Application%20Development%20Three%20Node%20Agent/ class=md-nav__link> <span class=md-ellipsis> Three Node Agent </span> </a> </li> <li class="md-nav__item md-nav__item--active"> <input class="md-nav__toggle md-toggle" type=checkbox id=__toc> <label class="md-nav__link md-nav__link--active" for=__toc> <span class=md-ellipsis> Agent with Specified Tools </span> <span class="md-nav__icon md-icon"></span> </label> <a href=./ class="md-nav__link md-nav__link--active"> <span class=md-ellipsis> Agent with Specified Tools </span> </a> <nav class="md-nav md-nav--secondary" aria-label="Table of contents"> <label class=md-nav__title for=__toc> <span class="md-nav__icon md-icon"></span> Table of contents </label> <ul class=md-nav__list data-md-component=toc data-md-scrollfix> <li class=md-nav__item> <a href=#overview class=md-nav__link> <span class=md-ellipsis> Overview </span> </a> </li> <li class=md-nav__item> <a href=#development-steps class=md-nav__link> <span class=md-ellipsis> Development Steps </span> </a> <nav class=md-nav aria-label="Development Steps"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#1-register-tools class=md-nav__link> <span class=md-ellipsis> 1. Register Tools </span> </a> </li> <li class=md-nav__item> <a href=#2-configure-decision-node-decide-node class=md-nav__link> <span class=md-ellipsis> 2. Configure Decision Node (Decide Node) </span> </a> </li> <li class=md-nav__item> <a href=#3-configure-decision-node-preprocessing-and-postprocessing class=md-nav__link> <span class=md-ellipsis> 3. Configure Decision Node Preprocessing and Postprocessing </span> </a> <nav class=md-nav aria-label="3. Configure Decision Node Preprocessing and Postprocessing"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#31-set-preprocessor-function class=md-nav__link> <span class=md-ellipsis> 3.1 Set Preprocessor Function </span> </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#4-configure-conditional-routing class=md-nav__link> <span class=md-ellipsis> 4. Configure Conditional Routing </span> </a> </li> <li class=md-nav__item> <a href=#5-configure-tool-node-toolnode class=md-nav__link> <span class=md-ellipsis> 5. Configure Tool Node (ToolNode) </span> </a> <nav class=md-nav aria-label="5. Configure Tool Node (ToolNode)"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#51-create-toolnode-instance class=md-nav__link> <span class=md-ellipsis> 5.1 Create ToolNode Instance </span> </a> </li> <li class=md-nav__item> <a href=#52-set-preprocessor-function class=md-nav__link> <span class=md-ellipsis> 5.2 Set Preprocessor Function </span> </a> </li> <li class=md-nav__item> <a href=#53-set-postprocessor-function class=md-nav__link> <span class=md-ellipsis> 5.3 Set Postprocessor Function </span> </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#6-configure-tool-node-routing class=md-nav__link> <span class=md-ellipsis> 6. Configure Tool Node Routing </span> </a> </li> <li class=md-nav__item> <a href=#7-configure-answer-node-answer-node class=md-nav__link> <span class=md-ellipsis> 7. Configure Answer Node (Answer Node) </span> </a> </li> <li class=md-nav__item> <a href=#8-connect-nodes class=md-nav__link> <span class=md-ellipsis> 8. Connect Nodes </span> </a> </li> <li class=md-nav__item> <a href=#9-create-workflow-and-execute class=md-nav__link> <span class=md-ellipsis> 9. Create Workflow and Execute </span> </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#complete-example class=md-nav__link> <span class=md-ellipsis> Complete Example </span> </a> </li> <li class=md-nav__item> <a href=#your-answer class=md-nav__link> <span class=md-ellipsis> YOUR ANSWER: </span> </a> </li> <li class=md-nav__item> <a href=#toolnode-vs-onefuncnode-comparison class=md-nav__link> <span class=md-ellipsis> ToolNode vs OneFuncNode Comparison </span> </a> <nav class=md-nav aria-label="ToolNode vs OneFuncNode Comparison"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#advantages-of-using-toolnode class=md-nav__link> <span class=md-ellipsis> Advantages of Using ToolNode </span> </a> </li> <li class=md-nav__item> <a href=#scenarios-for-using-onefuncnode class=md-nav__link> <span class=md-ellipsis> Scenarios for Using OneFuncNode </span> </a> </li> <li class=md-nav__item> <a href=#selection-recommendations class=md-nav__link> <span class=md-ellipsis> Selection Recommendations </span> </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#key-points class=md-nav__link> <span class=md-ellipsis> Key Points </span> </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=../10%20Application%20Development%20Inja%20Template%20Formatting/ class=md-nav__link> <span class=md-ellipsis> Inja Template Formatting </span> </a> </li> </ul> </nav> </li> </ul> </nav> </div> </div> </div> <div class="md-sidebar md-sidebar--secondary" data-md-component=sidebar data-md-type=toc> <div class=md-sidebar__scrollwrap> <div class=md-sidebar__inner> <nav class="md-nav md-nav--secondary" aria-label="Table of contents"> <label class=md-nav__title for=__toc> <span class="md-nav__icon md-icon"></span> Table of contents </label> <ul class=md-nav__list data-md-component=toc data-md-scrollfix> <li class=md-nav__item> <a href=#overview class=md-nav__link> <span class=md-ellipsis> Overview </span> </a> </li> <li class=md-nav__item> <a href=#development-steps class=md-nav__link> <span class=md-ellipsis> Development Steps </span> </a> <nav class=md-nav aria-label="Development Steps"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#1-register-tools class=md-nav__link> <span class=md-ellipsis> 1. Register Tools </span> </a> </li> <li class=md-nav__item> <a href=#2-configure-decision-node-decide-node class=md-nav__link> <span class=md-ellipsis> 2. Configure Decision Node (Decide Node) </span> </a> </li> <li class=md-nav__item> <a href=#3-configure-decision-node-preprocessing-and-postprocessing class=md-nav__link> <span class=md-ellipsis> 3. Configure Decision Node Preprocessing and Postprocessing </span> </a> <nav class=md-nav aria-label="3. Configure Decision Node Preprocessing and Postprocessing"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#31-set-preprocessor-function class=md-nav__link> <span class=md-ellipsis> 3.1 Set Preprocessor Function </span> </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#4-configure-conditional-routing class=md-nav__link> <span class=md-ellipsis> 4. Configure Conditional Routing </span> </a> </li> <li class=md-nav__item> <a href=#5-configure-tool-node-toolnode class=md-nav__link> <span class=md-ellipsis> 5. Configure Tool Node (ToolNode) </span> </a> <nav class=md-nav aria-label="5. Configure Tool Node (ToolNode)"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#51-create-toolnode-instance class=md-nav__link> <span class=md-ellipsis> 5.1 Create ToolNode Instance </span> </a> </li> <li class=md-nav__item> <a href=#52-set-preprocessor-function class=md-nav__link> <span class=md-ellipsis> 5.2 Set Preprocessor Function </span> </a> </li> <li class=md-nav__item> <a href=#53-set-postprocessor-function class=md-nav__link> <span class=md-ellipsis> 5.3 Set Postprocessor Function </span> </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#6-configure-tool-node-routing class=md-nav__link> <span class=md-ellipsis> 6. Configure Tool Node Routing </span> </a> </li> <li class=md-nav__item> <a href=#7-configure-answer-node-answer-node class=md-nav__link> <span class=md-ellipsis> 7. Configure Answer Node (Answer Node) </span> </a> </li> <li class=md-nav__item> <a href=#8-connect-nodes class=md-nav__link> <span class=md-ellipsis> 8. Connect Nodes </span> </a> </li> <li class=md-nav__item> <a href=#9-create-workflow-and-execute class=md-nav__link> <span class=md-ellipsis> 9. Create Workflow and Execute </span> </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#complete-example class=md-nav__link> <span class=md-ellipsis> Complete Example </span> </a> </li> <li class=md-nav__item> <a href=#your-answer class=md-nav__link> <span class=md-ellipsis> YOUR ANSWER: </span> </a> </li> <li class=md-nav__item> <a href=#toolnode-vs-onefuncnode-comparison class=md-nav__link> <span class=md-ellipsis> ToolNode vs OneFuncNode Comparison </span> </a> <nav class=md-nav aria-label="ToolNode vs OneFuncNode Comparison"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#advantages-of-using-toolnode class=md-nav__link> <span class=md-ellipsis> Advantages of Using ToolNode </span> </a> </li> <li class=md-nav__item> <a href=#scenarios-for-using-onefuncnode class=md-nav__link> <span class=md-ellipsis> Scenarios for Using OneFuncNode </span> </a> </li> <li class=md-nav__item> <a href=#selection-recommendations class=md-nav__link> <span class=md-ellipsis> Selection Recommendations </span> </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#key-points class=md-nav__link> <span class=md-ellipsis> Key Points </span> </a> </li> </ul> </nav> </div> </div> </div> <div class=md-content data-md-component=content> <article class="md-content__inner md-typeset"> <h1 id=conditional-routing-agent-with-tool-node-development-example>Conditional Routing Agent with Tool Node Development Example</h1> <h2 id=overview>Overview</h2> <p>This example demonstrates how to use <code>ToolNode</code> to implement a conditional routing agent. Unlike using <code>OneFuncNode</code> to manually invoke tools, <code>ToolNode</code> provides a more concise and standardized way to invoke tools, especially suitable for scenarios that need to invoke registered tools.</p> <p><strong>Workflow Diagram:</strong></p> <pre><code>Input → decide_node (Decision) → [Conditional Routing]
                                  ├─ &quot;search&quot; → web_search_node (ToolNode) → decide_node (Loop)
                                  └─ &quot;answer&quot; → answer_node (Generate Answer) → Output
</code></pre> <p><strong>Core Features:</strong> - <strong>Tool Node</strong>: Uses <code>ToolNode</code> to encapsulate tool invocation logic, making code more concise - <strong>Conditional Routing</strong>: Dynamically select the next node based on the decision node's output - <strong>Loop Workflow</strong>: Supports looping between decision node and search node until sufficient information is obtained - <strong>Context Accumulation</strong>: Each search result accumulates into the context for subsequent decisions</p> <p><strong>Differences from Using OneFuncNode:</strong> - <code>OneFuncNode</code>: Requires manually calling <code>common_tools::tools::call_tool</code>, suitable for scenarios requiring complex custom logic - <code>ToolNode</code>: Automatically handles tool invocation, specifies tool name and parameters through preprocessor function, code is more concise, suitable for directly invoking registered tools</p> <h2 id=development-steps>Development Steps</h2> <h3 id=1-register-tools>1. Register Tools</h3> <p>Same as a single node agent, you need to register the required tools first. This example uses the <code>search_web2</code> tool for web search:</p> <pre><code class=language-c++>#include &lt;tools.h&gt;
#include &lt;web_search.h&gt;

common_tools::tools::add_function_call(search_web_tool,
    R&quot;({&quot;type&quot;:&quot;function&quot;,&quot;function&quot;:{&quot;name&quot;:&quot;search_web2&quot;,&quot;description&quot;:&quot;Search the web using keywords to get general information that doesn't change over time, supporting filtering by country, etc. to get web content, titles, and link information&quot;,&quot;parameters&quot;:{&quot;type&quot;:&quot;object&quot;,&quot;properties&quot;:{&quot;query&quot;:{&quot;type&quot;:&quot;string&quot;,&quot;description&quot;:&quot;Search query string used to search for relevant information on the web. Keyword combinations should be concise and clear, avoiding redundant information while ensuring they accurately reflect the core needs of the user's question. Keyword combinations should conform to search engine syntax and logical rules&quot;,&quot;minLength&quot;:1},&quot;country&quot;:{&quot;type&quot;:&quot;string&quot;,&quot;description&quot;:&quot;Country name (must be in English) used to limit search results from a specific country&quot;,&quot;enum&quot;:[&quot;china&quot;,&quot;usa&quot;,&quot;japan&quot;,&quot;...&quot;]}},&quot;required&quot;:[&quot;query&quot;]}}})&quot;
);
</code></pre> <h3 id=2-configure-decision-node-decide-node>2. Configure Decision Node (Decide Node)</h3> <p>The decision node is responsible for analyzing the current context and deciding the next action (search or answer):</p> <pre><code class=language-c++>chat_node::chat_node_settings s1;
s1.model = &quot;gpt-4o-mini&quot;;
s1.temperature = 0.7;
s1.top_p = 0.95;
s1.max_tokens = 2048;
s1.tool_choice = &quot;none&quot;; 
const auto decide_node = std::make_shared&lt;chat_node::ChatNode&lt;std::string, std::string&gt;&gt;(s1);
</code></pre> <h3 id=3-configure-decision-node-preprocessing-and-postprocessing>3. Configure Decision Node Preprocessing and Postprocessing</h3> <h4 id=31-set-preprocessor-function>3.1 Set Preprocessor Function</h4> <p>The preprocessor function builds a decision prompt containing the question, existing context, and available actions:</p> <pre><code class=language-c++>decide_node-&gt;setPreprocessor([&amp;](const std::string&amp; in) -&gt; std::string {
    nlohmann::json inJson = nlohmann::json::parse(in);

    g_question = inJson[0][&quot;content&quot;].get&lt;std::string&gt;();

    std::string prompt = build_ws_prompt(g_question, g_context);
    inJson[0][&quot;content&quot;] = prompt;
    return inJson.dump();
});
</code></pre> <p><code>build_ws_prompt</code> function example:</p> <pre><code class=language-c++>static std::string build_ws_prompt(const std::string &amp;question, const std::string &amp;context) {
    auto now = std::chrono::system_clock::now();
    const std::string local_time = fmt::format(&quot;{:%Y-%m-%d %H:%M:%S}&quot;, now);

    return R&quot;(### CONTEXT
You are a research assistant that can search the web.
Question: )&quot; + question + R&quot;(
Previous Research: )&quot; + context + R&quot;(

### ACTION SPACE
[1] search
Description: Look up more information on the web
Parameters:
    - query (str): What to search for

[2] answer
Description: Answer the question with current knowledge
Parameters:
    - answer (str): Final answer to the question

## NEXT ACTION
Decide the next action based on the context and available actions.
Return your response in this format:

```yaml
thinking: |
    &lt;your step-by-step reasoning process&gt;
action: search OR answer
reason: |
    &lt;why you chose this action&gt;
answer: |
    &lt;if action is answer&gt;
search_query: &lt;specific search query if action is search&gt;
</code></pre> <p>Current time: )" + local_time; }</p> <pre><code>
#### 3.2 Set Postprocessor Function

The postprocessor function parses the YAML-formatted decision result and extracts the action type and parameters:

```c++
decide_node-&gt;setPostprocessor([&amp;](const std::string&amp; output) -&gt; std::string {
    nlohmann::json output_Json = nlohmann::json::parse(output);

    // Extract and clean response content (remove code block markers)
    std::string cleaned_response = StripFenceRegex(
        output_Json.back()[&quot;content&quot;].get&lt;std::string&gt;());

    // Parse YAML
    g_yaml_node = YAML::Load(cleaned_response);

    // Check required fields
    if (!g_yaml_node[&quot;thinking&quot;] || !g_yaml_node[&quot;action&quot;] || !g_yaml_node[&quot;reason&quot;]) {
        HYB_LOG_WARN(&quot;Missing required YAML fields&quot;);
        return &quot;search&quot;;  // Default to search on error
    }

    // Return different values based on action type
    if (g_yaml_node[&quot;action&quot;].as&lt;std::string&gt;() == &quot;search&quot;) {
        return g_yaml_node[&quot;search_query&quot;].as&lt;std::string&gt;();  // Return search query
    }

    if (g_yaml_node[&quot;action&quot;].as&lt;std::string&gt;() == &quot;answer&quot;) {
        // Build final answer prompt
        std::string prompt = R&quot;(### CONTEXT
Based on the following information, answer the question.
Question: )&quot; + g_question + R&quot;(
Research: )&quot; + g_context + R&quot;(

## YOUR ANSWER:
Provide a comprehensive answer using the research results.)&quot;;
        return prompt;
    }

    return &quot;search&quot;;  // Default to search
});
</code></pre> <h3 id=4-configure-conditional-routing>4. Configure Conditional Routing</h3> <p>Use the <code>route</code> function to configure conditional routing for the decision node, selecting the next node based on the postprocessor function's output:</p> <pre><code class=language-c++>route(decide_node, [&amp;](const std::string &amp;input, const std::string &amp;output) -&gt; std::optional&lt;std::string&gt; {
    if (g_yaml_node[&quot;action&quot;].as&lt;std::string&gt;() == &quot;search&quot;) {
        return &quot;search&quot;;  // Route to search node
    }

    if (g_yaml_node[&quot;action&quot;].as&lt;std::string&gt;() == &quot;answer&quot;) {
        return &quot;answer&quot;;  // Route to answer node
    }

    return std::nullopt;  // No matching route
});
</code></pre> <p><strong>Parameter Description:</strong> - First parameter: Source node (<code>decide_node</code>) - Second parameter: Route function that receives input and output, returns route name (<code>std::optional&lt;std::string&gt;</code>)</p> <h3 id=5-configure-tool-node-toolnode>5. Configure Tool Node (ToolNode)</h3> <p><strong>Key Difference: Use <code>ToolNode</code> instead of <code>OneFuncNode</code></strong></p> <p><code>ToolNode</code> is a node type specifically designed for invoking registered tools. It receives tool name and parameters through a preprocessor function and automatically handles tool invocation.</p> <h4 id=51-create-toolnode-instance>5.1 Create ToolNode Instance</h4> <pre><code class=language-c++>#include &lt;tool_node.h&gt;

const auto web_search_node = std::make_shared&lt;tool_node::ToolNode&lt;std::string, std::string&gt;&gt;();
</code></pre> <h4 id=52-set-preprocessor-function>5.2 Set Preprocessor Function</h4> <p>The preprocessor function needs to convert the input to the format expected by <code>ToolNode</code>: a JSON object containing the tool name and parameters.</p> <pre><code class=language-c++>// Need to save query string for postprocessor function to use
std::string g_query = &quot;&quot;;

web_search_node-&gt;setPreprocessor([&amp;](const std::string&amp; in) -&gt; std::string {
    // Save search query for postprocessor function to use
    g_query = in;

    // Build tool parameters JSON
    nlohmann::json tool_args_json;
    tool_args_json[&quot;query&quot;] = in;  // in is the search query string

    // Build input format required by ToolNode: contains tool name and parameters
    nlohmann::json tool_input_json;
    tool_input_json[&quot;name&quot;] = &quot;search_web2&quot;;  // Specify using search_web2 tool
    tool_input_json[&quot;arguments&quot;] = tool_args_json.dump();  // Parameters need to be JSON string

    return tool_input_json.dump();
});
</code></pre> <p><strong>ToolNode Input Format Description:</strong> - <code>name</code>: Tool name (string), must be a registered tool name - <code>arguments</code>: Tool parameters (JSON string), must be valid JSON format</p> <p><strong>Note</strong>: Since the postprocessor function cannot directly access the preprocessor function's input, if you need to use input data in the postprocessor function, you need to save it to an external variable (such as <code>g_query</code>) in the preprocessor function.</p> <h4 id=53-set-postprocessor-function>5.3 Set Postprocessor Function</h4> <p>The postprocessor function processes the tool's return result, parsing and formatting search results:</p> <pre><code class=language-c++>web_search_node-&gt;setPostprocessor([&amp;](const std::string&amp; output) -&gt; std::string {
    nlohmann::json ws_out_json = nlohmann::json::parse(output);
    std::string web_content;

    try {
        // Extract actual search results from wrapped JSON
        if (ws_out_json.contains(&quot;content&quot;) &amp;&amp; 
            ws_out_json[&quot;content&quot;].is_array() &amp;&amp; 
            !ws_out_json[&quot;content&quot;].empty()) {
            const auto &amp;first = ws_out_json[&quot;content&quot;][0];
            if (first.contains(&quot;type&quot;) &amp;&amp; 
                first[&quot;type&quot;].get&lt;std::string&gt;() == &quot;text&quot; &amp;&amp; 
                first.contains(&quot;text&quot;)) {
                // Parse actual search results again
                nlohmann::json ws_payload = nlohmann::json::parse(
                    first[&quot;text&quot;].get&lt;std::string&gt;());

                // Extract and format search results
                if (ws_payload.contains(&quot;responses&quot;) &amp;&amp; 
                    ws_payload[&quot;responses&quot;].is_array()) {
                    for (const auto &amp;resp : ws_payload[&quot;responses&quot;]) {
                        web_content +=
                            &quot;TITLE: &quot; + resp[&quot;title&quot;].get&lt;std::string&gt;() +
                            &quot;\nURL: &quot; + resp[&quot;url&quot;].get&lt;std::string&gt;() +
                            &quot;\nSNIPPET: &quot; + resp[&quot;snippet&quot;].get&lt;std::string&gt;() +
                            &quot;\n\n&quot;;
                    }
                }
            }
        }
    } catch (const std::exception &amp;e) {
        HYB_LOG_ERROR(&quot;Failed to parse search results: {}&quot;, e.what());
    }

    // Accumulate context (using query string saved in preprocessor function)
    std::string new_context = 
        g_context +
        &quot;\n\nSEARCH: &quot; + (!g_query.empty() ? g_query : &quot;No query&quot;) +
        &quot;\n\nRESULTS: \n&quot; + 
        (!web_content.empty() ? web_content : &quot;No results&quot;);

    g_context = new_context;

    // Return question for re-entering decision node
    nlohmann::json output_json = nlohmann::json::array();
    output_json.push_back({{&quot;role&quot;, &quot;user&quot;}, {&quot;content&quot;, g_question}});
    return output_json.dump();
});
</code></pre> <h3 id=6-configure-tool-node-routing>6. Configure Tool Node Routing</h3> <p>The tool node always returns to the decision node after execution, forming a loop:</p> <pre><code class=language-c++>route(web_search_node, [&amp;](const std::string &amp;input, const std::string &amp;output) -&gt; std::optional&lt;std::string&gt; {
    return &quot;decide&quot;;  // Always route back to decision node
});
</code></pre> <h3 id=7-configure-answer-node-answer-node>7. Configure Answer Node (Answer Node)</h3> <p>The answer node generates the final answer:</p> <pre><code class=language-c++>chat_node::chat_node_settings s_answer;
const auto answer_node = std::make_shared&lt;chat_node::ChatNode&lt;std::string, std::string&gt;&gt;(s_answer);

answer_node-&gt;setPreprocessor([&amp;](const std::string &amp;in) -&gt; std::string {
    // Convert input to Chat Completion format
    nlohmann::json inJson = nlohmann::json::array();
    inJson.push_back({{&quot;role&quot;, &quot;user&quot;}, {&quot;content&quot;, in}});
    return inJson.dump();
});
</code></pre> <h3 id=8-connect-nodes>8. Connect Nodes</h3> <p>Use the <code>chain</code> function to establish connections between nodes:</p> <pre><code class=language-c++>// Decision node to tool node
nodeflow::chain(decide_node, web_search_node, &quot;search&quot;);

// Decision node to answer node
nodeflow::chain(decide_node, answer_node, &quot;answer&quot;);

// Tool node back to decision node (forms loop)
nodeflow::chain(web_search_node, decide_node, &quot;decide&quot;);
</code></pre> <h3 id=9-create-workflow-and-execute>9. Create Workflow and Execute</h3> <pre><code class=language-c++>// Create workflow
auto f = std::make_shared&lt;nodeflow::Flow&gt;();

// Set start node
f-&gt;start(decide_node);

// Execute workflow
auto result = f-&gt;runWithInput&lt;std::string, std::string&gt;(question);
</code></pre> <p><strong>Execution Flow:</strong> 1. Input question enters <code>decide_node</code> 2. <code>decide_node</code> analyzes context and decides to search or answer 3. If search is chosen: - Route to <code>web_search_node</code> (ToolNode) - ToolNode automatically invokes <code>search_web2</code> tool - Search results accumulate into context - Route back to <code>decide_node</code> (loop) 4. If answer is chosen: - Route to <code>answer_node</code> to generate final answer - Return result</p> <h2 id=complete-example>Complete Example</h2> <p>The following is a complete conditional routing agent implementation example using ToolNode:</p> <pre><code class=language-c++>#include &lt;chat_node.h&gt;
#include &lt;log_util.hpp&gt;
#include &lt;nodeflow.hpp&gt;
#include &lt;tool_node.h&gt;
#include &lt;tools.h&gt;
#include &lt;web_search.h&gt;
#include &lt;nlohmann/json.hpp&gt;
#include &lt;yaml-cpp/yaml.h&gt;
#include &lt;fmt/chrono.h&gt;
#include &lt;chrono&gt;
#include &lt;regex&gt;
#include &lt;iostream&gt;

std::string StripFenceRegex(std::string s) {
    s = std::regex_replace(s, std::regex(R&quot;(^\s*```[^\r\n]*\r?\n)&quot;), &quot;&quot;);
    s = std::regex_replace(s, std::regex(R&quot;((?:\r?\n)?\s*```\s*$)&quot;), &quot;&quot;);
    return s;
}

static std::string build_ws_prompt(const std::string &amp;question, const std::string &amp;context) {
    auto now = std::chrono::system_clock::now();
    const std::string local_time = fmt::format(&quot;{:%Y-%m-%d %H:%M:%S}&quot;, now);

    return R&quot;(### CONTEXT
You are a research assistant that can search the web.
Question: )&quot; + question + R&quot;(
Previous Research: )&quot; + context + R&quot;(

### ACTION SPACE
[1] search
Description: Look up more information on the web
Parameters:
    - query (str): What to search for

[2] answer
Description: Answer the question with current knowledge
Parameters:
    - answer (str): Final answer to the question

## NEXT ACTION
Decide the next action based on the context and available actions.
Return your response in this format:

```yaml
thinking: |
    &lt;your step-by-step reasoning process&gt;
action: search OR answer
reason: |
    &lt;why you chose this action&gt;
answer: |
    &lt;if action is answer&gt;
search_query: &lt;specific search query if action is search&gt;
</code></pre> <p>Current time: )" + local_time; }</p> <p>// Register tools common_tools::tools::add_function_call(search_web_tool, R"({"type":"function","function":{"name":"search_web2","description":"Search the web using keywords to get general information that doesn't change over time, supporting filtering by country, etc. to get web content, titles, and link information","parameters":{"type":"object","properties":{"query":{"type":"string","description":"Search query string used to search for relevant information on the web. Keyword combinations should be concise and clear, avoiding redundant information while ensuring they accurately reflect the core needs of the user's question. Keyword combinations should conform to search engine syntax and logical rules","minLength":1},"country":{"type":"string","description":"Country name (must be in English) used to limit search results from a specific country","enum":["china","usa","japan","..."]}},"required":["query"]}}})" );</p> <p>std::string call_tool_impl_cpp(const std::string &amp;question) { try { // State variables std::string g_context = ""; std::string g_question = ""; std::string g_query = ""; YAML::Node g_yaml_node = YAML::Node();</p> <pre><code>    // Configure decision node
    chat_node::chat_node_settings s1;
    s1.model = "gpt-4o-mini";
    s1.temperature = 0.7;
    s1.top_p = 0.95;
    s1.max_tokens = 2048;
    s1.tool_choice = "none";
    const auto decide_node = std::make_shared&lt;chat_node::ChatNode&lt;std::string, std::string&gt;&gt;(s1);

    // Set decision node's preprocessor function
    decide_node-&gt;setPreprocessor([&amp;](const std::string&amp; in) -&gt; std::string {
        nlohmann::json inJson = nlohmann::json::parse(in);
        g_question = inJson[0]["content"].get&lt;std::string&gt;();
        std::string prompt = build_ws_prompt(g_question, g_context);
        inJson[0]["content"] = prompt;
        return inJson.dump();
    });

    decide_node-&gt;setPostprocessor([&amp;](const std::string&amp; output) -&gt; std::string {
        nlohmann::json output_Json = nlohmann::json::parse(output);
        std::string cleaned_response = StripFenceRegex(
            output_Json.back()["content"].get&lt;std::string&gt;());

        g_yaml_node = YAML::Load(cleaned_response);

        if (!g_yaml_node["thinking"] || !g_yaml_node["action"] || !g_yaml_node["reason"]) {
            HYB_LOG_WARN("Missing required YAML fields");
            return "search";
        }

        HYB_LOG_INFO("Thinking: {}", g_yaml_node["thinking"].as&lt;std::string&gt;());
        HYB_LOG_INFO("Action: {}", g_yaml_node["action"].as&lt;std::string&gt;());
        HYB_LOG_INFO("Reason: {}", g_yaml_node["reason"].as&lt;std::string&gt;());

        if (g_yaml_node["action"].as&lt;std::string&gt;() == "search") {
            return g_yaml_node["search_query"].as&lt;std::string&gt;();
        }

        if (g_yaml_node["action"].as&lt;std::string&gt;() == "answer") {
            std::string prompt = R"(### CONTEXT
</code></pre> <p>Based on the following information, answer the question. Question: )" + g_question + R"( Research: )" + g_context + R"(</p> <h2 id=your-answer>YOUR ANSWER:</h2> <p>Provide a comprehensive answer using the research results.)"; return prompt; }</p> <pre><code>        return "search";
    });

    // Configure decision node's conditional routing
    route(decide_node, [&amp;](const std::string &amp;input, const std::string &amp;output) -&gt; std::optional&lt;std::string&gt; {
        if (g_yaml_node["action"].as&lt;std::string&gt;() == "search") {
            HYB_LOG_INFO("Routing to search node");
            return "search";
        }
        if (g_yaml_node["action"].as&lt;std::string&gt;() == "answer") {
            HYB_LOG_INFO("Routing to answer node");
            return "answer";
        }
        return std::nullopt;
    });

    // Configure tool node (using ToolNode)
    const auto web_search_node = std::make_shared&lt;tool_node::ToolNode&lt;std::string, std::string&gt;&gt;();

    // Set tool node's preprocessor function
    web_search_node-&gt;setPreprocessor([&amp;](const std::string&amp; in) -&gt; std::string {
        // Save search query for postprocessor function to use
        g_query = in;

        // Build tool parameters JSON
        nlohmann::json tool_args_json;
        tool_args_json["query"] = in;  // in is the search query string

        // Build input format required by ToolNode: contains tool name and parameters
        nlohmann::json tool_input_json;
        tool_input_json["name"] = "search_web2";  // Specify using search_web2 tool
        tool_input_json["arguments"] = tool_args_json.dump();  // Parameters need to be JSON string

        return tool_input_json.dump();
    });

    // Set tool node's postprocessor function
    web_search_node-&gt;setPostprocessor([&amp;](const std::string&amp; output) -&gt; std::string {
        nlohmann::json ws_out_json = nlohmann::json::parse(output);
        std::string web_content;

        try {
            if (ws_out_json.contains("content") &amp;&amp; 
                ws_out_json["content"].is_array() &amp;&amp; 
                !ws_out_json["content"].empty()) {
                const auto &amp;first = ws_out_json["content"][0];
                if (first.contains("type") &amp;&amp; 
                    first["type"].get&lt;std::string&gt;() == "text" &amp;&amp; 
                    first.contains("text")) {
                    // Parse actual search results again
                    nlohmann::json ws_payload = nlohmann::json::parse(
                        first["text"].get&lt;std::string&gt;());
                    if (ws_payload.contains("responses") &amp;&amp; 
                        ws_payload["responses"].is_array()) {
                        for (const auto &amp;resp : ws_payload["responses"]) {
                            web_content +=
                                "TITLE: " + resp["title"].get&lt;std::string&gt;() +
                                "\nURL: " + resp["url"].get&lt;std::string&gt;() +
                                "\nSNIPPET: " + resp["snippet"].get&lt;std::string&gt;() +
                                "\n\n";
                        }
                    }
                }
            }
        } catch (const std::exception &amp;e) {
            HYB_LOG_ERROR("Failed to parse search results: {}", e.what());
        }

        // Accumulate context
        std::string new_context = 
            g_context +
            "\n\nSEARCH: " + (!g_query.empty() ? g_query : "No query") +
            "\n\nRESULTS: \n" + 
            (!web_content.empty() ? web_content : "No results");

        g_context = new_context;

        // Return question for re-entering decision node
        nlohmann::json output_json = nlohmann::json::array();
        output_json.push_back({{"role", "user"}, {"content", g_question}});
        return output_json.dump();
    });

    // Configure tool node's routing (always returns to decision node)
    route(web_search_node, [&amp;](const std::string &amp;input, const std::string &amp;output) -&gt; std::optional&lt;std::string&gt; {
        return "decide";
    });

    // Configure answer node
    chat_node::chat_node_settings s_answer;
    const auto answer_node = std::make_shared&lt;chat_node::ChatNode&lt;std::string, std::string&gt;&gt;(s_answer);
    answer_node-&gt;setPreprocessor([&amp;](const std::string &amp;in) -&gt; std::string {
        nlohmann::json inJson = nlohmann::json::array();
        inJson.push_back({{"role", "user"}, {"content", in}});
        return inJson.dump();
    });

    // Connect nodes
    nodeflow::chain(decide_node, web_search_node, "search");
    nodeflow::chain(decide_node, answer_node, "answer");
    nodeflow::chain(web_search_node, decide_node, "decide");

    // Create workflow and execute
    auto f = std::make_shared&lt;nodeflow::Flow&gt;();
    f-&gt;start(decide_node);
    auto result = f-&gt;runWithInput&lt;std::string, std::string&gt;(question);

    return result;
} catch (const std::exception &amp;ex) {
    HYB_LOG_ERROR(std::string("call_tool_impl_cpp exception: ") + ex.what());
    return R"({"ok":false,"error":"exception"})";
} catch (...) {
    HYB_LOG_ERROR("call_tool_impl_cpp unknown exception");
    return R"({"ok":false,"error":"unknown exception"})";
}
</code></pre> <p>}</p> <p>int main() { // Build input message nlohmann::json inputJson = nlohmann::json::array(); inputJson.push_back({ {"role", "user"}, {"content", "What is the latest news about artificial intelligence?"} });</p> <pre><code>// Call agent and get response
std::string response = call_tool_impl_cpp(inputJson.dump());

// Output result
std::cout &lt;&lt; response &lt;&lt; std::endl;

return 0;
</code></pre> <p>} ```</p> <h2 id=toolnode-vs-onefuncnode-comparison>ToolNode vs OneFuncNode Comparison</h2> <h3 id=advantages-of-using-toolnode>Advantages of Using ToolNode</h3> <ol> <li><strong>More Concise Code</strong>: No need to manually call <code>common_tools::tools::call_tool</code>, ToolNode handles it automatically</li> <li><strong>Standardized Interface</strong>: Unified tool invocation format, easier to maintain and debug</li> <li><strong>Error Handling</strong>: ToolNode has built-in error handling and logging for tool invocation</li> <li><strong>Type Safety</strong>: Clear input and output types through template parameters</li> </ol> <h3 id=scenarios-for-using-onefuncnode>Scenarios for Using OneFuncNode</h3> <ol> <li><strong>Complex Custom Logic</strong>: Need to perform complex data processing before and after tool invocation</li> <li><strong>Multiple Tool Combinations</strong>: Need to invoke multiple tools or perform other operations in one node</li> <li><strong>Special Error Handling</strong>: Need custom error handling logic</li> </ol> <h3 id=selection-recommendations>Selection Recommendations</h3> <ul> <li><strong>Prefer ToolNode</strong>: When you only need to invoke a single registered tool</li> <li><strong>Use OneFuncNode</strong>: When you need complex custom logic or multiple tool combinations</li> </ul> <h2 id=key-points>Key Points</h2> <ol> <li><strong>ToolNode Input Format</strong>: Must contain <code>name</code> (tool name) and <code>arguments</code> (parameters in JSON string format)</li> <li><strong>Preprocessor Function</strong>: Convert input to the format expected by ToolNode</li> <li><strong>Postprocessor Function</strong>: Process tool return results, usually need to parse JSON and format</li> <li><strong>Conditional Routing</strong>: Use the <code>route</code> function to dynamically select the next node based on node output</li> <li><strong>Loop Workflow</strong>: Routing can implement loops between nodes, supporting iterative search</li> <li><strong>Context Management</strong>: Use global variables or state objects to manage context information in workflows</li> </ol> </article> </div> <script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script> </div> <button type=button class="md-top md-icon" data-md-component=top hidden> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8z"/></svg> Back to top </button> </main> <footer class=md-footer> <div class="md-footer-meta md-typeset"> <div class="md-footer-meta__inner md-grid"> <div class=md-copyright> <div class=md-copyright__highlight> Copyright &copy; 2025 LATC CTOO Lenovo Group </div> Made with <a href=https://squidfunk.github.io/mkdocs-material/ target=_blank rel=noopener> Material for MkDocs </a> </div> </div> </div> </footer> </div> <div class=md-dialog data-md-component=dialog> <div class="md-dialog__inner md-typeset"></div> </div> <script id=__config type=application/json>{"annotate": null, "base": "..", "features": ["navigation.tabs", "navigation.sections", "navigation.expand", "navigation.top", "search.suggest", "search.highlight", "content.code.annotate", "content.code.copy"], "search": "../assets/javascripts/workers/search.7a47a382.min.js", "tags": null, "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}, "version": null}</script> <script src=../assets/javascripts/bundle.e71a0d61.min.js></script> </body> </html>